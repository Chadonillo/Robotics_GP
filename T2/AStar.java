 package T2;

//Main contributors: James and Brandon
//@J The A* class was edited by Brandon to make it compatible with waypoints (functionality within LejOS and hence his navigator class).
// Before this, it was an independent implementation of the A* algorithm functional acting with the node class. More into these
// edits will be given in the descriptions below.
// An overview is here:
// The LejOS waypoint implementation simply involves objects of type waypoint with some useful methods associated. When building
// we decided to utilise these waypoints within the navigator class. The waypoint and nodes correspond exactly to each other, 
// we simply convert regularly perform simple conversions between them to save time. For example, a node on the grid at position
// (3, 9) corresponds to a waypoint at position (3, 9). To convert waypoint to node, we call the method on the waypoint that 
// returns the integer value of its x and y coordinates respectively and construct a corresponding node.
// The methods in this class generally take waypoints from Brandon's classes as parameters, rapidly initialise the relevant nodes
// using the node class, and then perform the A* pathfinding.
// Potentially, with more time, we could have rewrote this for cleaner code however the task was deemed to be a non priority given
// the efficiency of conversion and the suggestion from experimental trials that this was a non-issue.

import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

import lejos.robotics.navigation.Waypoint;
import lejos.robotics.pathfinding.Path;

//---------------------------------------------------------------------------------------------------
/*@J The algorithm chosen for pathfinding is the A* search algorithm. A* returns a path of nodes that correspond to waypoints that 
correspond to the physical course itself. This implementation models a grid (map) that does not use physical measurements
yet still proportionally links to the physical course environment. 
The development of A* and navigation was seperated for efficiency, the original task being to return a list of nodes
generated by a generic A* implementation. Seperating the workload in this way enabled us to work concurrently
and seperately without depending on the progress of each other making the team operation more efficient.
The algorithm moved from a generic implementation to a practical one when it was conjoined (by Brandon) to his
navigator functionality (using LejOS inbuilts such as waypoints that relate to physical distance) allowed the
algorithm to be used practically to traverse the course.

Functionality:
Blocked nodes specified within the map class - (Nodes can be dynamically blocked/made innaccessible on the grid/map depending on what Wall-z knows)
Blocked nodes are employed to prevent the EV3 from entering/colliding with 'out of bounds areas' (such as the walls) and
to prevent collision with objects. The robot should perform A* situationally and intelligently depending on information 
it deduces/obtains while completing the task (such as its position from localising on the localization strip, its knowledge
of variable obstacle locations from reading the colour strip or from being informed at the beginning of the task).
*/
//---------------------------------------------------------------------------------------------------

public class AStar {
//---------------------------------------------------------------------------------------------------
//hvCost is the horizontal or vertical cost of a generic diagonal movement from one node to another
    private int hvCost = 10; 
//diagonalCost is the diagonal cost of a generic diagonal movement from one node to another
    private int diagonalCost = 14;
    //@J Note that this need not correlate with actual physical measurements of distance and instead
    //is simply the sides of a triangle (horizontal, vertical and diagonal) retrived using
    //pythagoreas theorem. During testing, we altered these numbers artificially to encourage the
    //robot to prefer either h/v or diagonal movements and noted its behaviour. Inaccuracies with
    //turning and gyroscopic sensing surprisingly lead to some paths being performed with less or
    //more error simply depending upon whether they involved more turning (note that a diagonal move
    //usually requires Wall-Z to move 45 degrees whereas a horizontal often requires 90 degrees.

   //Now we initialise an open list (priority Queue dst) and closed set as require by the A* algo.
   //A map using the map class inside the project is also initialised containing the default arena setup.
    private Map map;
    private PriorityQueue<Node> openList;
    private Set<Node> closedSet;

	
//---------------------------------------------------------------------------------------------------
/*@J AStar takes an object of type map when being constructed. The Map class encodes information about the physical arena,
and so when the robot needs to pathfind, it uses this map. The map changes intelligently depending on what Wall-Z can
deduce from the environment allowing a multitude of potential routes depending on where Wall-Z is moving from, where
he is moving to, and what he knows about the arena (e.g. obstacle locations from reading colour strips).
*/
    public AStar(Map map) {
    	this.map = map;
        this.openList = new PriorityQueue<Node>(200, new Comparator<Node>(){
            @Override
            public int compare(Node node0, Node node1) {
                return Integer.compare(node0.getF(), node1.getF());
            }
        });
        this.closedSet = new HashSet<>();
    }
    
    public AStar(){
    	this(new Map());
    }
    	
	//METHODS
  //---------------------------------------------------------------------------------------------------
//@J The addBlock method blocks takes a Waypoint object as parameter and blocks this singular node from the map
    //(using the addBlockedNode method from within this class).
    //Waypoints contain the X and Y coordinate value that can be used directly as an integer value.
    public void addBlock(Waypoint addWayPoint){
    	this.map.addBlockedNode(new Node((int)addWayPoint.getY(), (int)addWayPoint.getX()));
    }
    
//@J The same explanation applies as above except addBlock takes a Path object as parameter and
//for the nodes encoded within this path blocks them from the map.
    public void addBlock(Path path){
    	for(Waypoint point : path){
    		this.map.addBlockedNode(new Node((int)point.getY(), (int)point.getX()));
    	}
    }
    
    public void removeBlock(Waypoint removeWayPoint){
    	this.map.removeBlockedNode(new Node((int)removeWayPoint.getY(), (int)removeWayPoint.getX()));
    }
    
    public void removeBlock(Path path){
    	for(Waypoint point : path){
    		this.map.removeBlockedNode(new Node((int)point.getY(), (int)point.getX()));
    	}
    }

    public Path findPath(Waypoint initialWaypoint, Waypoint finalWaypoint){
    	Node initialNode = new Node((int)initialWaypoint.getY(), (int)initialWaypoint.getX());
    	Node finalNode = new Node((int)finalWaypoint.getY(), (int)finalWaypoint.getX());
    	this.map.setHeuristic(finalNode);
        openList.add(initialNode);
        while (openList.size() != 0) {
            Node currentNode = openList.poll();
            closedSet.add(currentNode);
            if (currentNode.equals(finalNode)) {
                return shortenPath(listToPath(getPath(currentNode)));
            } else {
                addAdjacentNodes(currentNode);
            }
        }
        return new Path();
    }
    
    private Path listToPath(List<Node> list){
    	Path path = new Path();
    	for (Node node : list) {
    		path.add(new Waypoint(node.getCol(), node.getRow()));
    	}
		return path;
    }
    
    private Path shortenPath(Path longPath){
		if (longPath.isEmpty()){
			return longPath;
		}
		
		Path shortPath = new Path();
		float lastAngle = longPath.get(0).angleTo(longPath.get(1));
		shortPath.add(longPath.get(0));
		
		for (int i = 0; i < longPath.size()-1; i++){
			if(longPath.get(i).angleTo(longPath.get(i+1))!=lastAngle){
				lastAngle = longPath.get(i).angleTo(longPath.get(i+1));
				shortPath.add(longPath.get(i));		
			}
	    }
		shortPath.add(longPath.get(longPath.size()-1));
		return shortPath;
	}
    
    
    
    private List<Node> getPath(Node currentNode){
        List<Node> path = new ArrayList<Node>();
        path.add(currentNode);
        Node parent;
        while ((parent = currentNode.getParent()) != null) {
            path.add(0, parent);
            currentNode = parent;
        }
        return path;
    }

    private void addAdjacentNodes(Node currentNode){
        addAdjacentUpperRow(currentNode);
        addAdjacentMiddleRow(currentNode);
        addAdjacentLowerRow(currentNode);
    }
   
    private void addAdjacentLowerRow(Node currentNode){
        int row = currentNode.getRow();
        int col = currentNode.getCol();
        int lowerRow = row + 1;
        if (lowerRow < map.getMap().length) {
            if (col - 1 >= 0) {
                checkNode(currentNode, col - 1, lowerRow, this.diagonalCost); // Comment this line if diagonal movements are not allowed
            }
            if (col + 1 < map.getMap()[0].length) {
                checkNode(currentNode, col + 1, lowerRow, this.diagonalCost); // Comment this line if diagonal movements are not allowed
            }
            checkNode(currentNode, col, lowerRow, this.hvCost);
        }
    }
   
    private void addAdjacentMiddleRow(Node currentNode){
        int row = currentNode.getRow();
        int col = currentNode.getCol();
        int middleRow = row;
        if (col - 1 >= 0) {
            checkNode(currentNode, col - 1, middleRow, this.hvCost);
        }
        if (col + 1 < map.getMap()[0].length) {
            checkNode(currentNode, col + 1, middleRow, this.hvCost);
        }
    }
   
    private void addAdjacentUpperRow(Node currentNode){
        int row = currentNode.getRow();
        int col = currentNode.getCol();
        int upperRow = row - 1;
        if (upperRow >= 0) {
            if (col - 1 >= 0) {
                checkNode(currentNode, col - 1, upperRow, this.diagonalCost); // Comment this if diagonal movements are not allowed
            }
            if (col + 1 < map.getMap()[0].length) {
                checkNode(currentNode, col + 1, upperRow, this.diagonalCost); // Comment this if diagonal movements are not allowed
            }
            checkNode(currentNode, col, upperRow, this.hvCost);
        }
    }
   
    private void checkNode(Node currentNode, int col, int row, int cost){
        Node adjacentNode = map.getMap()[row][col];
        if (!adjacentNode.isBlock() && !this.closedSet.contains(adjacentNode)) {
            if (!this.openList.contains(adjacentNode)) {
                adjacentNode.setNodeData(currentNode, cost);
                this.openList.add(adjacentNode);
            } else {
                boolean changed = adjacentNode.checkBetterPath(currentNode, cost);
                if (changed) {
                    // Remove and Add the changed node, so that the PriorityQueue can sort again its
                    // contents with the modified "finalCost" value of the modified node
                    this.openList.remove(adjacentNode);
                    this.openList.add(adjacentNode);
                }
            }
        }
    }
}

