			//Obstacle Avoidance
			//Do something when ultrasonic sensor is less than obstacleDistance
			if(sampleDistance[0]*100 < obstacleDistance){
				//wallz.stop();
				pilot.rotate(35);// turn robot right
				Motor.D.rotate(-90);//turn sensor to look at obstacle
				
				integralOA = 0; //accumulated error
				derivativeOA = 0; //used to predict next error
				errorOA = 0;
				lastErrorOA = 0; //store the last error to be used to calculate the derivative
				
				//Update sensors
				// Update sensor with new data
				// Update sensor with new data
				ussProvider.fetchSample(sampleDistance, 0); // Update sensor with new data
				
				//wallz.drive(baseSpeed, baseSpeed);
				Delay.msDelay(100);
				
				while (!(lightLeft[0] < maxBlack) && !(lightRight[0] < maxBlack) && !Button.ESCAPE.isDown()){
					errorOA = sampleDistance[0]*100 - obstacleDistance;
					//Anti Wind-Up
					//Zero the integral, set the variable integral equal to zero,
					//every time the error is zero or the error changes sign
					if (Math.abs(errorOA) <= 1 || util.oppositeSigns((int)errorOA, (int)lastErrorOA)){
						integralOA=0;
					}
					else{
						integralOA = ((2/3) * integralOA) + errorOA; //update accumulated error, Dampen by multiplying by 2/3
					}
					derivativeOA = errorOA - lastErrorOA;
					
					pidValueOA = (errorOA * kpOA) + (integralOA * kiOA) + (derivativeOA * kdOA);
					//wallz.drive(baseSpeed + pidValueOA, baseSpeed - pidValueOA);
					lastErrorOA = errorOA;
					//Update sensors
					// Update sensor with new data
					// Update sensor with new data
					ussProvider.fetchSample(sampleDistance, 0); // Update sensor with new data
				}
				Motor.D.rotate(90, true);//turn sensor to look straight again, do not wait for motor to rotate
			
			}